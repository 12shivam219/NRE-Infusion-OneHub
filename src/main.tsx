import { StrictMode, memo } from 'react';
import { createRoot, Root } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { ThemeProvider } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import App from './App.tsx';
import { ErrorBoundary } from './components/common/ErrorBoundary';
import { setupGlobalErrorHandler } from './lib/errorReporting';
import { initSentry } from './lib/sentry';
import { ToastProvider } from './contexts/ToastContext';
import { ThemeModeProvider } from './contexts/ThemeModeProvider';
import { useThemeMode } from './hooks/useThemeMode';
import { crmThemeDark, crmThemeLight } from './lib/mui/crmTheme';
import './index.css';

// Initialize Sentry FIRST for error tracking
initSentry();

// Setup global error handlers
setupGlobalErrorHandler();

document.title = 'NRETech OneHub';

export const ThemedApp = memo(() => {
  const { themeMode } = useThemeMode();
  const theme = themeMode === 'dark' ? crmThemeDark : crmThemeLight;

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  );
});

const rootElement = document.getElementById('root') as HTMLElement & { __reactRoot?: Root };
if (rootElement && !rootElement.__reactRoot) {
  const root = createRoot(rootElement);
  // Mark the root element so we don't try to create root again
  rootElement.__reactRoot = root;
  root.render(
    <StrictMode>
      <BrowserRouter>
        <ErrorBoundary>
          <ToastProvider>
            <ThemeModeProvider>
              <ThemedApp />
            </ThemeModeProvider>
          </ToastProvider>
        </ErrorBoundary>
      </BrowserRouter>
    </StrictMode>
  );
}

// Register service worker for offline support (generated by VitePWA)
// Only register the service worker in production builds to avoid
// interfering with the Vite dev server / HMR during development.
if (import.meta.env?.PROD && 'serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('/sw.js')
      .then((reg) => console.log('Service worker registered:', reg))
      .catch((err) => console.warn('Service worker registration failed:', err));
  });
} else if (!import.meta.env?.PROD && 'serviceWorker' in navigator) {
  // Dev convenience: if an older service worker is registered (from a
  // previous production build or earlier dev run), unregister it so the
  // Vite HMR client won't load a stale service-worker-served file that
  // tries to connect to an unavailable/old dev server and causes
  // `WebSocket closed without opened.` errors.
  window.addEventListener('load', async () => {
    try {
      const reg = await navigator.serviceWorker.getRegistration('/sw.js');
      if (reg) {
        await reg.unregister();
        console.info('Dev: unregistered existing /sw.js to avoid stale caching/HMR issues');
        // Best-effort clear of application caches which might still serve
        // cached assets from the old registration.
        if (caches && caches.keys) {
          const keys = await caches.keys();
          await Promise.all(keys.map((k) => caches.delete(k)));
        }
      }
    } catch (err) {
      console.debug('Dev: no service worker to unregister or failed to unregister', err);
    }
  });
}
