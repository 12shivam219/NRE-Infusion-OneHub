import { StrictMode, memo, useEffect, useState } from 'react';
import { createRoot, Root } from 'react-dom/client';
import { BrowserRouter } from 'react-router-dom';
import { ThemeProvider, type Theme } from '@mui/material/styles';
import CssBaseline from '@mui/material/CssBaseline';
import App from './App.tsx';
import { ErrorBoundary } from './components/common/ErrorBoundary';
import { ToastProvider } from './contexts/ToastContext';
import './index.css';

// Defer heavy initialization to not block initial render
// These are executed in requestIdleCallback to avoid blocking the main thread
const deferInitialization = () => {
  if ('requestIdleCallback' in window) {
    requestIdleCallback(() => {
      import('./lib/sentry').then(({ initSentry }) => initSentry());
      import('./lib/errorReporting').then(({ setupGlobalErrorHandler }) => setupGlobalErrorHandler());
    });
  } else {
    // Fallback for browsers without requestIdleCallback
    setTimeout(() => {
      import('./lib/sentry').then(({ initSentry }) => initSentry());
      import('./lib/errorReporting').then(({ setupGlobalErrorHandler }) => setupGlobalErrorHandler());
    }, 100);
  }
};

// Start deferred initialization after first render
deferInitialization();

document.title = 'NRETech OneHub';

// Function to remove initial loader (CSP-compliant)
const hideInitialLoader = () => {
  const loader = document.getElementById('initial-loader');
  if (loader) {
    loader.style.opacity = '0';
    setTimeout(() => {
      loader.style.display = 'none';
    }, 300);
  }
};

// Lazy load theme creation to defer theme object instantiation
const cachedTheme: { light?: Theme } = {};

const getTheme = async (): Promise<Theme> => {
  if (cachedTheme.light) return cachedTheme.light;
  
  const { crmThemeLight } = await import('./lib/mui/crmTheme');
  cachedTheme.light = crmThemeLight;
  return crmThemeLight;
};

export const ThemedApp = memo(() => {
  const [theme, setTheme] = useState<Theme | null>(null);

  useEffect(() => {
    getTheme().then(setTheme);
  }, []);

  // Hide initial loader when React app mounts
  useEffect(() => {
    hideInitialLoader();
  }, []);

  if (!theme) {
    return null; // Don't render until theme is loaded
  }

  return (
    <ThemeProvider theme={theme}>
      <CssBaseline />
      <App />
    </ThemeProvider>
  );
});

const rootElement = document.getElementById('root') as HTMLElement & { __reactRoot?: Root };
if (rootElement && !rootElement.__reactRoot) {
  const root = createRoot(rootElement);
  // Mark the root element so we don't try to create root again
  rootElement.__reactRoot = root;
  root.render(
    <StrictMode>
      <BrowserRouter>
        <ErrorBoundary>
          <ToastProvider>
            <ThemedApp />
          </ToastProvider>
        </ErrorBoundary>
      </BrowserRouter>
    </StrictMode>
  );
}

// Register service worker for offline support (generated by VitePWA)
// Only register the service worker in production builds to avoid
// interfering with the Vite dev server / HMR during development.
if (import.meta.env?.PROD && 'serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker
      .register('/sw.js')
      .then((reg) => console.log('Service worker registered:', reg))
      .catch((err) => console.warn('Service worker registration failed:', err));
  });
} else if (!import.meta.env?.PROD && 'serviceWorker' in navigator) {
  // Dev convenience: if an older service worker is registered (from a
  // previous production build or earlier dev run), unregister it so the
  // Vite HMR client won't load a stale service-worker-served file that
  // tries to connect to an unavailable/old dev server and causes
  // `WebSocket closed without opened.` errors.
  window.addEventListener('load', async () => {
    try {
      const reg = await navigator.serviceWorker.getRegistration('/sw.js');
      if (reg) {
        await reg.unregister();
        console.info('Dev: unregistered existing /sw.js to avoid stale caching/HMR issues');
        // Best-effort clear of application caches which might still serve
        // cached assets from the old registration.
        if (caches && caches.keys) {
          const keys = await caches.keys();
          await Promise.all(keys.map((k) => caches.delete(k)));
        }
      }
    } catch (err) {
      console.debug('Dev: no service worker to unregister or failed to unregister', err);
    }
  });
}
